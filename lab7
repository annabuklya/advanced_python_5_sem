import random
class RNK:
    
    def __init__(self, chain):  
        self.chain = chain
        
        if 'T' in self.chain:
            
            raise ValueError('wrong sequnce')
    
    def __add__(rnk1, rnk2):
        
        return RNK(chain = rnk1.chain + rnk2.chain)
    
    def __repr__(self):
        return str(self.chain)
    
    def __str__(self):
        return str(self.chain)
    
    def search(self, i):
        return self.chain[i]
    
    def compl_DNK(self):
        
        dnk_chain1 = list(self.chain)
        
        for i in range(len(self.chain)): #ужасно костыльный кусок, который надо бы переписать через словарь,
            #зато все работает хотя бы с:
            
            if dnk_chain1[i] == 'A':         
                dnk_chain1[i] = 'T'
            elif dnk_chain1[i] == 'U':
                dnk_chain1[i] = 'A'
            elif dnk_chain1[i] == 'C':
                dnk_chain1[i] = 'G'
            elif dnk_chain1[i] == 'G':
                dnk_chain1[i] = 'C'
        dnk_chain1 = ''.join(dnk_chain1)
       
    
    
        dnk_chain2 = list(dnk_chain1)
        for i in range(len(dnk_chain2)): 
            if dnk_chain2[i] == 'A':         
                dnk_chain2[i] = 'T'
            elif dnk_chain2[i] == 'T':
                dnk_chain2[i] = 'A'
            elif dnk_chain2[i] == 'C':
                dnk_chain2[i] = 'G'
            elif dnk_chain2[i] == 'G':
                dnk_chain2[i] = 'C'
        dnk_chain2 = ''.join(dnk_chain2)
        
        
        return DNK(chain1 = dnk_chain1, chain2 = dnk_chain2)
    
    def multipl(self, rnk2):
        self.chain = list(self.chain)
        rnk2.chain = list(rnk2.chain)
        
        minn = min(len(self.chain), len(rnk2.chain))
        new_chain = []
        for i in range(minn):
            for_choice = [self.chain[i], rnk2.chain[i]]
            new_chain.append(random.choice(for_choice))
        
        if len(self.chain) > len(rnk2.chain):
            new_chain = new_chain + self.chain[minn:]
        else:
            new_chain = new_chain + rnk2.chain[minn:]
        new_chain = ''.join(new_chain)
        return RNK(new_chain)
    
    def  __eq__(self, rnk2):
        
        
        if self.chain == rnk2.chain:
            return True
        else:
            return False
        
        
class DNK:
    
    def __init__(self, chain1, chain2):  
        
        self.chain1 = chain1
        self.chain2 = chain2
        if 'U' in self.chain1 or 'U' in self.chain2:
            raise ValueError('wrong sequnce')
    
    def __repr__(self):
        
        return list(str(self.chain1), str(self.chain2))
    
    
    def __str__(self):
        
        return str(str(self.chain1) + ' ' + str(self.chain2))
        
    def compl_chain2(self):
        
        self.chain2 = list(self.chain1)
        for i in range(len(self.chain1)): 
            if self.chain2[i] == 'A':         
                self.chain2[i] = 'T'
            elif self.chain2[i] == 'T':
                self.chain2[i] = 'A'
            elif self.chain2[i] == 'C':
                self.chain2[i] = 'G'
            elif self.chain2[i] == 'G':
                self.chain2[i] = 'C'
        return ''.join(self.chain2)
        
    def __add__(dnk1, dnk2):
        
        return DNK(chain1 = dnk1.chain1 + dnk2.chain1, chain2 = dnk1.chain2 + dnk2.chain2)
    
    def search(self, i):
        return self.chain1[i] + ' ' + self.chain2[i]
    
    def multipl(self, dnk2):
        self.chain1 = list(self.chain1)
        dnk2.chain1 = list(dnk2.chain1)
        
        minn = min(len(self.chain1), len(dnk2.chain1))
        new_chain = []
        for i in range(minn):
            for_choice = [self.chain1[i], dnk2.chain1[i]]
            new_chain.append(random.choice(for_choice))
        
        if len(self.chain1) > len(dnk2.chain1):
            new_chain = new_chain + self.chain1[minn:]
        else:
            new_chain = new_chain + dnk2.chain1[minn:]
        new_chain = ''.join(new_chain)
        
        dnk_chain2 = list(new_chain)
        for i in range(len(dnk_chain2)): 
            if dnk_chain2[i] == 'A':         
                dnk_chain2[i] = 'T'
            elif dnk_chain2[i] == 'T':
                dnk_chain2[i] = 'A'
            elif dnk_chain2[i] == 'C':
                dnk_chain2[i] = 'G'
            elif dnk_chain2[i] == 'G':
                dnk_chain2[i] = 'C'
        dnk_chain2 = ''.join(dnk_chain2)
        
        
        return DNK(chain1 = new_chain, chain2 = dnk_chain2)
    
    def  __eq__(self, dnk2):
        
        
        if self.chain1 == dnk2.chain1 and self.chain2 == dnk2.chain2:
            return True
        else:
            return False
        
        
        
#rnk0 = RNK('ATGC')      тут проверка вызова ошибки

        
        
rnk1 = RNK('AUGC')
rnk2 = RNK('CGAUAU')

dnk1 = rnk1.compl_DNK()
dnk2 = rnk2.compl_DNK()

print(dnk1)
print(dnk2)

rnk3 = RNK('AAAA')
rnk4 = RNK('AAAA')




print(rnk1.search(2))
print(rnk1 + rnk2)
print(rnk2.compl_DNK())
print(rnk1.multipl(rnk2))
print(rnk1.compl_DNK())
print(rnk1.compl_DNK() + rnk2.compl_DNK())
print(dnk1.search(2))
print(dnk1.multipl(dnk2))
print(dnk1 == dnk2)
print(rnk3 == rnk4)
